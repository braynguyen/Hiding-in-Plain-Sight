<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steganalysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Monospaced font is key for the Matrix theme -->
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --matrix-green: #00ff41; /* Brighter green */
            --dark-green: #008f11;
            --bg-color: #000000;
            --text-color: var(--matrix-green);
            --border-color: #003300;
        }

        body {
            font-family: 'Roboto Mono', monospace; /* Monospaced for code feel */
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden; /* Hide scrollbars caused by canvas/glows */
            line-height: 1.6; /* Improve readability */
        }

        /* Canvas for Matrix Rain */
        #matrix-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Behind everything else */
            opacity: 0.7; /* Adjust opacity as needed */
        }

        /* --- Component Styling --- */

        .main-container {
             background-color: rgba(0, 10, 0, 0.7); /* Dark semi-transparent green */
             border: 1px solid var(--border-color);
             box-shadow: 0 0 15px rgba(0, 255, 65, 0.2);
             backdrop-filter: blur(2px); /* Optional: Blur background slightly */
             -webkit-backdrop-filter: blur(2px);
        }

        .text-glow {
             text-shadow: 0 0 5px var(--matrix-green), 0 0 10px var(--matrix-green);
        }

        .border-glow {
             box-shadow: 0 0 8px var(--matrix-green);
        }

        /* Loading spinner */
        .loader {
            border: 3px solid #004d00; /* Darker green track */
            border-top: 3px solid var(--matrix-green); /* Bright green spinner */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 0.7s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Fade-in animation */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .fade-in {
            animation: fadeIn 0.6s ease-out forwards;
        }

        /* Scan Line Animation (Green) */
        .scanline-container {
            position: relative;
            overflow: hidden;
            border-radius: 4px;
        }
        .scanline::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px; /* Thinner scan line */
            background: linear-gradient(90deg, transparent, var(--matrix-green), transparent);
            box-shadow: 0 0 5px var(--matrix-green), 0 0 8px var(--matrix-green);
            animation: scan 2s linear infinite;
            opacity: 0.9;
        }
        @keyframes scan {
            0% { top: 0%; }
            50% { top: 100%; }
            100% { top: 0%; }
        }

         /* Message box styling */
        .message-box {
            padding: 0.6rem 1rem;
            margin-bottom: 1rem;
            border-radius: 2px; /* Sharp corners */
            font-size: 0.9rem;
            border: 1px solid;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, max-height 0.3s ease-in-out, margin-bottom 0.3s ease-in-out;
            max-height: 0;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.8); /* More solid background for readability */
            font-family: 'VT323', monospace; /* Even more retro font */
            letter-spacing: 1px;
        }
        .message-box.show {
             opacity: 1;
             max-height: 100px;
             margin-bottom: 1rem;
        }
        /* Using white/red for contrast against green background */
        .message-error {
            color: #ff4d4d; /* Bright Red */
            border-color: #800000;
            text-shadow: 0 0 5px #ff0000;
        }
         .message-info {
            color: #ffffff; /* White */
            border-color: #cccccc;
             text-shadow: 0 0 3px #ffffff;
        }

         /* Log Output Styling */
        .log-output-container {
             background-color: rgba(0, 0, 0, 0.85);
             border: 1px solid var(--border-color);
             height: 120px; /* Fixed height */
             overflow-y: scroll; /* Enable scrolling */
             padding: 8px;
             font-family: 'VT323', monospace; /* Use the retro font */
             font-size: 1rem; /* Slightly larger */
             color: var(--matrix-green);
             border-radius: 2px;
             scrollbar-width: thin;
             scrollbar-color: var(--matrix-green) rgba(0,0,0,0.5);
        }
         /* Custom scrollbar for WebKit */
        .log-output-container::-webkit-scrollbar { width: 8px; }
        .log-output-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.5); }
        .log-output-container::-webkit-scrollbar-thumb { background-color: var(--dark-green); border-radius: 4px; border: 1px solid var(--matrix-green); }


    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <!-- Background Canvas -->
    <canvas id="matrix-canvas"></canvas>

    <!-- Main UI Container -->
    <div class="main-container rounded-md p-6 md:p-8 max-w-xl w-full transition-all duration-300 ease-in-out z-10 relative">

        <div class="text-center mb-6">
            <h1 class="text-4xl md:text-4xl font-bold text-glow mb-1 font-['VT323']">STEGANALYSIS</h1>
            <p class="text-sm text-gray-400">DECODE YOUR IMAGE</p>
        </div>

        <div id="message-area"></div>

        <div id="upload-area" class="mb-5 transition-all duration-300">
            <label for="image-upload"
                   class="cursor-pointer block border border-dashed border-[var(--border-color)] hover:border-[var(--matrix-green)] bg-[rgba(0,0,0,0.5)] rounded-sm p-6 text-center transition-colors duration-300 group hover:shadow-[inset_0_0_10px_rgba(0,255,65,0.3)]">
                <input type="file" id="image-upload" class="hidden" accept="image/*">
                <!-- Icon -->
                <svg class="mx-auto h-10 w-10 text-gray-600 group-hover:text-[var(--matrix-green)] transition-colors mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="filter: drop-shadow(0 0 3px var(--matrix-green));"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg> <!-- Changed Icon -->
                <p class="text-lg font-medium text-[var(--text-color)] font-['VT323']">SELECT SOURCE FILE</p>
                <p class="text-xs text-gray-500">[ PNG | JPG | GIF ]</p>
                <!-- Image Preview Area -->
                <div class="mt-3 relative mx-auto max-w-[180px]">
                     <img id="image-preview" src="#" alt="Source Preview" class="max-h-32 mx-auto rounded-sm hidden border border-[#002200]"/>
                </div>
                <p id="filename-display" class="text-sm text-green-300 mt-2 truncate"></p>
            </label>
        </div>

        <!-- Analysis Section -->
        <div id="analysis-section" class="text-center hidden mb-5 fade-in">
             <p class="text-lg font-medium mb-3 text-glow font-['VT323']">[ PROCESSING DATA STREAM... ]</p>
             <!-- Preview with Scanline -->
             <div class="scanline-container relative inline-block mb-3 border border-green-700 rounded-sm">
                 <img id="analysis-preview" src="#" alt="Analyzing Source" class="max-h-40 mx-auto rounded-sm block"/>
                 <div class="scanline"></div>
             </div>
            <!-- Log Output -->
            <div class="log-output-container">
                <pre id="log-output" class="whitespace-pre-wrap break-words"></pre>
            </div>
        </div>


        <!-- Results Section -->
        <div id="results-section" class="hidden bg-[rgba(0,0,0,0.6)] p-5 rounded-sm border border-[#003300] shadow-inner">
            <h2 class="text-xl font-semibold mb-4 text-center font-['VT323'] text-glow">[ ANALYSIS REPORT ]</h2>
            <div id="result-content" class="text-center text-sm">
                <!-- Results injected here -->
            </div>
            <button id="reset-button" class="mt-5 w-full bg-transparent hover:bg-[var(--dark-green)] border border-[var(--matrix-green)] text-[var(--matrix-green)] font-bold py-2 px-4 rounded-sm transition-all duration-200 ease-in-out focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-offset-black focus:ring-green-400 hover:shadow-[0_0_10px_rgba(0,255,65,0.5)] text-xs">
                // RESET INTERFACE //
            </button>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('matrix-canvas');
        const ctx = canvas.getContext('2d');
        const uploadArea = document.getElementById('upload-area');
        const imageUpload = document.getElementById('image-upload');
        const imagePreview = document.getElementById('image-preview');
        const analysisPreview = document.getElementById('analysis-preview');
        const filenameDisplay = document.getElementById('filename-display');
        const analysisSection = document.getElementById('analysis-section');
        const resultsSection = document.getElementById('results-section');
        const resultContent = document.getElementById('result-content');
        const resetButton = document.getElementById('reset-button');
        const uploadLabel = uploadArea.querySelector('label');
        const messageArea = document.getElementById('message-area');
        const logOutput = document.getElementById('log-output');

        // --- Matrix Rain Config ---
        let animationFrameId = null;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const katakana = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン';
        const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const nums = '0123456789';
        const matrixChars = katakana + latin + nums;
        const fontSize = 16;
        let columns = Math.floor(canvas.width / fontSize); // Use let for reassignment
        const drops = []; // y-position of drops in each column
        function initializeDrops() {
             drops.length = 0; // Clear existing drops
             columns = Math.floor(canvas.width / fontSize);
             for (let x = 0; x < columns; x++) {
                drops[x] = 1 + Math.random() * canvas.height / fontSize; // Start drops randomly
             }
        }
        initializeDrops(); // Initial setup

        // --- Matrix Rain Drawing Function ---
        function drawMatrix() {
            // Black BG for the canvas, slightly transparent to create fading trails
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Trails effect
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--matrix-green').trim() || '#00ff41'; // Use CSS var or fallback
            ctx.font = fontSize + 'px monospace';

            // Loop through drops
            for (let i = 0; i < drops.length; i++) {
                const text = matrixChars.charAt(Math.floor(Math.random() * matrixChars.length));
                // Draw character - use Math.floor for y position to ensure integer pixel value
                ctx.fillText(text, i * fontSize, Math.floor(drops[i] * fontSize));

                // Send drop back to top randomly after it crosses the screen
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                // Increment Y coordinate (adjust speed here)
                drops[i] += 0.10; // Slowed down speed
            }
             animationFrameId = requestAnimationFrame(drawMatrix); // Continue the loop
        }

        // --- Resize Handler ---
         window.addEventListener('resize', () => {
             cancelAnimationFrame(animationFrameId); // Stop animation
             canvas.width = window.innerWidth;
             canvas.height = window.innerHeight;
             initializeDrops(); // Reinitialize drops for new width
             drawMatrix(); // Restart animation
         });


        // --- UI Logic ---
        // *** UPDATED API ENDPOINT ***
        const API_ENDPOINT = 'http://localhost:5000/analyze';
        let logInterval = null;

        imageUpload.addEventListener('change', handleFileSelect);
        uploadLabel.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); uploadLabel.classList.add('border-[var(--matrix-green)]', 'bg-[rgba(0,50,0,0.3)]'); });
        uploadLabel.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); uploadLabel.classList.remove('border-[var(--matrix-green)]', 'bg-[rgba(0,50,0,0.3)]'); });
        uploadLabel.addEventListener('drop', (e) => {
            e.preventDefault(); e.stopPropagation();
            uploadLabel.classList.remove('border-[var(--matrix-green)]', 'bg-[rgba(0,50,0,0.3)]');
            if (e.dataTransfer.files.length > 0) { imageUpload.files = e.dataTransfer.files; handleFileSelect(); }
        });
        resetButton.addEventListener('click', resetApp);

        function showMessage(text, type = 'info') {
            messageArea.innerHTML = ''; // Clear previous messages
            const messageDiv = document.createElement('div');
            messageDiv.textContent = `// ${type.toUpperCase()}_MSG: ${text}`;
            messageDiv.className = `message-box message-${type}`;
            messageArea.appendChild(messageDiv);
            // Force reflow to trigger transition
            void messageDiv.offsetWidth;
            messageDiv.classList.add('show');
             // Auto-hide after some time
             setTimeout(() => {
                 messageDiv.classList.remove('show');
                 // Remove from DOM after transition ends
                 setTimeout(() => { if (messageArea.contains(messageDiv)) messageArea.removeChild(messageDiv); }, 300);
             }, 6000); // Hide after 6 seconds
        }

        function hideMessages() {
             const messages = messageArea.querySelectorAll('.message-box.show');
             messages.forEach(msg => {
                 msg.classList.remove('show');
                 setTimeout(() => { if (messageArea.contains(msg)) messageArea.removeChild(msg); }, 300);
             });
        }

        function handleFileSelect() {
            hideMessages();
            const file = imageUpload.files[0];

            if (file && file.type.startsWith('image/')) {
                filenameDisplay.textContent = `SRC: ${file.name}`;
                filenameDisplay.classList.remove('hidden');
                const reader = new FileReader();
                reader.onload = (e) => {
                    const imageUrl = e.target.result;
                    imagePreview.src = imageUrl; imagePreview.classList.remove('hidden');
                    analysisPreview.src = imageUrl;
                }
                reader.readAsDataURL(file);
                // Short delay before switching view
                setTimeout(() => {
                    uploadArea.classList.add('hidden');
                    resultsSection.classList.add('hidden'); // Ensure results are hidden initially
                    analysisSection.classList.remove('hidden');
                    analysisSection.classList.add('fade-in');
                    logs = startLogSimulation();
                    analyzeImage(file, logs); // Start analysis
                }, 150);
            } else if (file) {
                showMessage('Signal Rejected. Valid Image Source Required.', 'error');
                resetApp(); // Reset if invalid file type selected
            } else {
                 resetApp(); // Reset if no file selected after dialog (e.g., user cancels)
            }
        }

        function startLogSimulation() {
            clearInterval(logInterval); // Clear any previous interval
            logOutput.innerHTML = 'Initiating Analysis Sequence...\n'; // Clear previous logs
            const logs = [
                "Establishing link to Analysis Core @ " + API_ENDPOINT.replace(/http:\/\//, ''), // Show target
                "Transmitting source data stream...",
                "Verifying data integrity...",
                "Core Acknowledged. Processing Request...", // Changed message
                "Analyzing pixel matrix...",
                "Scanning for LSB anomalies...",
                "Checking structural signatures...",
                "Cross-referencing known patterns...",
                "Compiling analysis vectors...",
                "Awaiting report generation..." // Changed message
            ];
            let logIndex = 0;
            logOutput.scrollTop = logOutput.scrollHeight; // Scroll down initially

            logInterval = setInterval(() => {
                if (logIndex < logs.length) {
                    logOutput.innerHTML += `> ${logs[logIndex]}\n`;
                    logOutput.scrollTop = logOutput.scrollHeight; // Auto-scroll
                    logIndex++;
                } else {
                    // Stop the simulation once all logs are displayed,
                    // but don't clear interval here; clear it in analyzeImage's finally block
                    // to ensure it runs until the fetch completes.
                     clearInterval(logInterval); // Keep interval running until fetch done
                }
            }, 350); // Slightly adjusted interval
            return logs;
        }

        // *** UPDATED analyzeImage Function ***
        async function analyzeImage(file, logs) {
            const formData = new FormData();
            // Ensure the key 'image' matches what your Flask backend expects
            formData.append('image', file);

            // Log simulation continues while fetch happens...

            try {
                // Let initial logs appear
                await new Promise(resolve => setTimeout(resolve, logs.length * 350 + 100)); // Wait for logs

                logOutput.innerHTML += '> Fetching report from Core...\n';
                logOutput.scrollTop = logOutput.scrollHeight;

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    body: formData,
                    // No 'Content-Type' header needed manually for FormData with fetch
                    // Browser sets 'multipart/form-data' with correct boundary
                });
                console.log("responded")

                logOutput.innerHTML += `> Core Response Status: ${response.status} ${response.statusText}\n`;
                logOutput.scrollTop = logOutput.scrollHeight;

                if (!response.ok) {
                    let errorMsg = `Analysis Core Error (${response.status})`;
                    try {
                        // Try to parse potential JSON error from backend
                        const errorData = await response.json();
                        errorMsg += `: ${errorData.error || JSON.stringify(errorData)}`;
                    } catch (e) {
                        // If response is not JSON or empty
                        errorMsg += ` - ${response.statusText}`;
                    }
                     throw new Error(errorMsg);
                }

                const data = await response.json();

                logOutput.innerHTML += '> Analysis Complete. Report Received.\n';
                logOutput.scrollTop = logOutput.scrollHeight;

                 // Optional short delay to let user see the final log message
                 await new Promise(resolve => setTimeout(resolve, 300));

                displayResults(data);

            } catch (error) {
                console.error('Analysis System Error:', error);
                // Display error using our function
                displayError(`Link Error: ${error.message || 'Cannot reach Analysis Core. Check connection or server status.'}`);

            } finally {
                 // Ensure log interval is always cleared
                clearInterval(logInterval);
                // Hide analysis section, show results section (even for errors)
                analysisSection.classList.add('hidden');
                resultsSection.classList.remove('hidden');
                resultsSection.classList.add('fade-in');
            }
        }

        // *** UPDATED displayResults Function ***
        function displayResults(data) {
            // Basic file info
            let resultHTML = `<p class="text-xs text-gray-400 mb-3 text-center">Source: ${data.filename || 'N/A'} | Size: ${data.file_size != null ? data.file_size + ' bytes' : 'N/A'}</p>`;

            // Overall Detection Status Box
            if (data.steganography_detected) {
                resultHTML += `
                    <div class="border border-red-500 bg-black/70 p-3 rounded-sm mb-4">
                        <p class="text-lg font-bold text-red-500 text-glow font-['VT323'] text-center">!! ANOMALY DETECTED !!</p>
                    </div>`;
            } else {
                resultHTML += `
                     <div class="border border-green-600 bg-black/70 p-3 rounded-sm mb-4">
                        <p class="text-lg font-bold text-[var(--matrix-green)] text-glow font-['VT323'] text-center">[ SOURCE STREAM CLEAR ]</p>
                    </div>`;
            }

            // Conclusion Text
            resultHTML += `<p class="text-base text-center text-gray-200 mb-4">Conclusion: <span class="font-bold ${data.steganography_detected ? 'text-white' : 'text-gray-300'}">${data.conclusion || (data.steganography_detected ? 'Hidden data likely present.' : 'No definitive signs of hidden data.')}</span></p>`;

            // Detailed Detection Methods
            resultHTML += `<h3 class="text-base font-semibold text-gray-400 font-['VT323'] mb-2 text-center">// DETECTION VECTORS //</h3>`;
            resultHTML += `<div class="text-left text-xs space-y-2 border-t border-b border-dashed border-gray-700 py-3 px-2 mb-3 bg-black/30">`; // Container for details

            if (data.detection_methods && typeof data.detection_methods === 'object') {
                 for (const [method, details] of Object.entries(data.detection_methods)) {
                    const methodClass = details.detected ? 'text-red-400' : 'text-gray-500';
                    const detectedMarker = details.detected ? '<span class="text-red-500 font-bold">[+]</span> ' : '<span class="text-green-600">[-]</span> '; // Green for not detected here
                    const methodName = method.replace(/_/g, ' ').toUpperCase();

                    resultHTML += `<div class="${methodClass}">`;
                    resultHTML += `${detectedMarker}<strong>${methodName}:</strong> ${details.details || 'No details provided.'}`;

                    // Display confidence if available and non-zero (adjust threshold as needed)
                    if (details.confidence != null && details.confidence > 0) {
                         resultHTML += ` (Confidence: ${(details.confidence * 100).toFixed(1)}%)`;
                    }
                    // Display specific metrics if available
                    if (details.chi_square_value != null) resultHTML += ` (Chi²: ${details.chi_square_value.toFixed(2)})`;
                    if (details.randomness_score != null) resultHTML += ` (Rand: ${details.randomness_score.toFixed(1)}%)`;
                    if (details.bit_distribution_score != null) resultHTML += ` (Dist: ${details.bit_distribution_score.toExponential(2)})`; // Use scientific notation if small

                    // Display extracted sample if detected and available
                    if (details.detected && details.sample) {
                        // Basic HTML escaping for the sample
                        const escapedSample = document.createElement('textarea');
                        escapedSample.textContent = details.sample;
                        resultHTML += `<br />   <span class="text-yellow-300">Extracted (${details.data_type || 'data'}):</span> <code class="bg-gray-800 px-1 rounded text-white whitespace-pre-wrap break-all">${escapedSample.innerHTML}</code>`;
                    }
                    resultHTML += `</div>`;
                }
            } else {
                 resultHTML += `<p class="text-gray-500 text-center">No detailed analysis methods reported.</p>`;
            }

            resultHTML += `</div>`; // Close details container

            // Final recommendation text
             if (data.steganography_detected) {
                 resultHTML += `<p class="text-xs text-gray-500 mt-2 text-center">// Recommend Isolate & Manual Investigation //</p>`;
             } else {
                 resultHTML += `<p class="text-xs text-gray-500 mt-2 text-center">// System Nominal - Monitoring Active //</p>`;
             }

            resultContent.innerHTML = resultHTML;
        }

        // *** UPDATED displayError Function ***
         function displayError(errorMessage) {
            // Show message in the top bar
            showMessage(errorMessage, 'error');

            // Also display a formatted error in the main results area
             resultContent.innerHTML = `
                 <div class="border border-red-700 bg-black/70 p-3 rounded-sm mb-3">
                     <p class="text-lg font-bold text-red-500 text-glow font-['VT323'] text-center">[ SYSTEM ERROR / OFFLINE ]</p>
                 </div>
                 <p class="text-base text-red-300 text-center break-words">${errorMessage}</p>
                 <p class="text-xs text-gray-500 mt-3 text-center">// Check console log [F12] for technical details //</p>
                 <p class="text-xs text-gray-500 text-center">// Verify Analysis Core @ ${API_ENDPOINT} is running //</p>`;

            // Ensure results section is visible to show the error message there too
             analysisSection.classList.add('hidden'); // Hide analysis progress
             resultsSection.classList.remove('hidden'); // Show results area
             resultsSection.classList.add('fade-in');
        }

        function resetApp() {
            hideMessages();
            clearInterval(logInterval); // Stop any running log interval
            imageUpload.value = ''; // Clear file input
            imagePreview.classList.add('hidden'); imagePreview.src = '#'; // Hide preview
            analysisPreview.src = '#';
            filenameDisplay.textContent = ''; filenameDisplay.classList.add('hidden'); // Clear filename
            uploadArea.classList.remove('hidden'); // Show upload area
            analysisSection.classList.add('hidden'); // Hide analysis section
            resultsSection.classList.add('hidden'); // Hide results section
            resultContent.innerHTML = ''; // Clear previous results
            logOutput.innerHTML = ''; // Clear logs
        }

        // --- Start Matrix Rain ---
        drawMatrix();

    </script>

</body>
</html>